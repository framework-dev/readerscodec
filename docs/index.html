<!doctype html>
<notebook theme="air">
  <title>Readers Codec</title>
  <script id="1" type="text/markdown">
    # Readers Codec
  </script>
  <script id="2" type="module" pinned="">
    spelNeighborhood("it_19")
  </script>
  <script id="3" type="module" pinned="">
    let newHTML = Array.from(spels.values())
      .map((spel) => spel.html)
      .join("");
    let displayElem = htl.html`<div id="display" class="set"></div>`;
    displayElem.innerHTML = newHTML;
    display(displayElem);
  </script>
  <script id="38" type="module" pinned="">
    let currentSpelIndex = 0;
    let intervalId;
    let isAnimating = false;

    function cycleSpels() {
      const spelIds = Array.from(spels.keys());

      if (spelIds.length === 0) return;

      // Clear previous highlights
      document.querySelectorAll('.spel').forEach(spel => {
        spel.style.backgroundColor = 'navajowhite';
      });

      // Get current spel
      const currentSpelId = spelIds[currentSpelIndex];
      const currentSpelElement = document.getElementById(currentSpelId);

      if (currentSpelElement) {
        // Highlight center spel in yellow
        currentSpelElement.style.backgroundColor = 'yellow';

        // Get neighborhood and highlight in pink
        const neighborhood = spelNeighborhood(currentSpelId);
        console.log(neighborhood);
        neighborhood.forEach((neighborSpel, index) => {
          if (neighborSpel && index !== 4) { // Skip center (index 4)
            const neighborElement = document.getElementById(neighborSpel);
            if (neighborElement) {
              neighborElement.style.backgroundColor = 'pink';
            }
          }
        });
      }

      // Move to next spel
      currentSpelIndex = (currentSpelIndex + 1) % spelIds.length;
    }

    function toggleAnimation() {
      if (!isAnimating) {
        // Start animation
        isAnimating = true;
        intervalId = setInterval(cycleSpels, 1000);
        toggleButton.textContent = 'Stop Animation';
      } else {
        // Stop animation
        isAnimating = false;
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
        // Reset all backgrounds
        document.querySelectorAll('.spel').forEach(spel => {
          spel.style.backgroundColor = 'navajowhite';
        });
        toggleButton.textContent = 'Start Animation';
      }
    }

    // Create and display the toggle button
    const toggleButton = htl.html`<button onclick=${toggleAnimation}>Start Animation</button>`;
    display(toggleButton);

    // Stop animation when cell is invalidated
    invalidation.then(() => {
      if (intervalId) {
        clearInterval(intervalId);
      }
      // Reset all backgrounds
      document.querySelectorAll('.spel').forEach(spel => {
        spel.style.backgroundColor = 'navajowhite';
      });
    });
  </script>
  <script id="4" type="module" pinned="">
    const theimage = fetch("data/theImage.txt")
      .then((response) => response.ok ? response.text() : Promise.reject(response.status));
      // .then(display);
  </script>
  <script id="5" type="module" pinned="">
    const draft = htl.html`<div class="set">${theimage}</div>`; // this element is not display but is used by the spanned element below
  </script>
  <script id="6" type="module" pinned="">
    paras
  </script>
  <script id="7" type="application/vnd.observable.javascript" pinned="">
    spels
  </script>
  <script id="8" type="module" pinned="">
    const spelsArray = Array.from(spels.entries()).map(([id, spel]) => ({ id, ...spel }));
    display(spelsArray)
  </script>
  <script id="9" type="application/vnd.observable.javascript" pinned="">
    scores = scoresDefaultTTR; // scoresFromAlignment([maplebridgepoem]) // scoresDefaultTTR // change this to what is actually required before Download JSON
  </script>
  <script id="10" type="application/vnd.observable.javascript" pinned="">
    parasConfig = ({ draft: [] }) // , draft2: [], draft3: [], draft4: [] })
    // Edit and construct this literal with properties that match
    // the cell names of paragraphs.
    // Other configuration is done in the config StrictObj:
  </script>
  <script id="11" type="application/vnd.observable.javascript" pinned="">
    config = {
      let obj = {
        paraNames: Object.keys(parasConfig),
        paraCells: [draft], //, draft2, draft3, draft4],
        spannedCells: [spanned] // , spanned2, spanned3, spanned4]
      };
      return new StrictObj(obj);
    }
  </script>
  <script id="12" type="application/vnd.observable.javascript" pinned="">
    spels = mapParaSpels(config.get("spannedCells"), config.get("paraNames"))
  </script>
  <script id="13" type="module" pinned="">
    //   const sameLine = (spel, threshold = 0.5) =>
    //     allSpels.filter(s => Math.abs(s.topvw - spel.topvw) <= threshold && s.id !== spel.id);
    // display(sameLine(spels.get("tongue_1")));
    // display(spels.get("tongue_1"));
  </script>
  <script id="14" type="text/x-typescript" pinned="">
    const spelsIterator = spels.entries()
    let sameLineFromMap = (spel, threshold = 0.5) =>
      spelsIterator.filter(s => Math.abs(s.topvw - spel.topvw) <= threshold && s.id !== spel.id);
    display(sameLineFromMap(spels.get("tongue_1")));
    display(spelsIterator.next());
    display(spelsIterator.next());
    display(spelsIterator.next());
  </script>
  <script id="15" type="application/vnd.observable.javascript" pinned="">
    paras = {
      let pArray = Array.from(Object.values(parasConfig));
      pArray = pArray.map((a) => a.map((i) => i.id));
      return pArray;
    }
  </script>
  <script id="16" type="application/vnd.observable.javascript" pinned="">
    spanString = Array.from(spels.values())
      .map((spel) => spel.html)
      .join("")
  </script>
  <script id="17" type="module" pinned="">
    function spelNeighborhood(spelId) {
    /**
     * Returns the 9-element neighborhood array for the spel which has the spelId passed as its argument
     *
     * [0] [1] [2]
     * [3] [4] [5]
     * [6] [7] [8]
     *
     * [4] is the center spel and its value is return as undefined
     * any element not satisfying the criteria below is undefined
     * [3] is the preceding spel and [5] is the next spel (normally on the same line)
     * if the center spel is the first spell of its line then [3] is the last spel of the line above
     * if the center spel is the last spel of its line then [5] is the first spel of the line below
     * [1] is the spel that is most immediately above the center spel on the line above
     * [7] is the spel this is most immediately below the center spel on the line below
     * [0] is the spel to the left of [1] if it overlaps at all with the center spel
     * [2] is the spel to the right of [1] if it overlaps at all with the center spel
     * [6] is the spel to the left of [7] if it overlaps at all with the center spel
     * [8] is the spel to the right of [7] if it overlaps at all with the center spel
     */
      const neighborhood = new Array(9).fill(undefined);

      // Find the spel and its position
      if (!spels.has(spelId)) {
        console.warn(`Spel id "${spelId}" not found`);
        return neighborhood;
      }

      const centerSpel = spels.get(spelId);
      const centerElem = document.getElementById(spelId);
      const lineHeightPx = parseFloat(window.getComputedStyle(centerElem.parentElement).lineHeight);
      const lineHeight = pxToVw(lineHeightPx);

      // [4] = undefined (center)
      neighborhood[4] = undefined;

      // Helper function to find spels on the same line (within vertical threshold)
      const getSpelsOnLine = (spelTopvw, threshold = 0.5) =>
        spelsArray.filter(s => Math.abs(s.topvw - spelTopvw) <= threshold);

      // Helper function to check if two spels overlap horizontally
      const spelsOverlap = (spel1, spel2, slop = 0) => {
        const elem1 = document.getElementById(spel1.id);
        const elem2 = document.getElementById(spel2.id);
        const left1 = spel1.leftvw;
        const right1 = spel1.leftvw + pxToVw(elem1.offsetWidth) + 1;
        const left2 = spel2.leftvw;
        const right2 = spel2.leftvw + pxToVw(elem2.offsetWidth) + 1;

        return (left1 - slop <= right2) && (right1 + slop >= left2);
      };

      // Helper function to find the first and last line positions
      const getFirstLastLinePositions = () => {
        const allTopPositions = spelsArray.map(s => s.topvw).sort((a, b) => a - b);
        const uniqueTopPositions = [...new Set(allTopPositions)];
        return {
          firstLine: uniqueTopPositions[0],
          lastLine: uniqueTopPositions[uniqueTopPositions.length - 1]
        };
      };

      // Helper function to find next non-blank line below given position
      const findNextNonBlankLine = (currentTopvw) => {
        const allTopPositions = spelsArray.map(s => s.topvw).sort((a, b) => a - b);
        const uniqueTopPositions = [...new Set(allTopPositions)];

        for (let i = 0; i < uniqueTopPositions.length; i++) {
          if (uniqueTopPositions[i] > currentTopvw) {
            const spelsOnLine = getSpelsOnLine(uniqueTopPositions[i]);
            if (spelsOnLine.length > 0) {
              return uniqueTopPositions[i];
            }
          }
        }
        return null;
      };

      // Get spels on the same line as center
      const centerLineSpels = getSpelsOnLine(centerSpel.topvw).filter(s => s.id !== centerSpel.id);

      // [3] = preceding spel (normally on same line, or last spel of line above if center is first)
      const leftSpels = centerLineSpels.filter(s => s.leftvw < centerSpel.leftvw);
      if (leftSpels.length > 0) {
        // There are spels to the left on the same line
        neighborhood[3] = leftSpels.reduce((closest, s) =>
          s.leftvw > closest.leftvw ? s : closest
        ).id;
      } else {
        // Center spel is first on its line, so [3] is last spel of line above
        const aboveLineSpels = getSpelsOnLine(centerSpel.topvw - lineHeight);
        if (aboveLineSpels.length > 0) {
          neighborhood[3] = aboveLineSpels.reduce((rightmost, s) =>
            s.leftvw > rightmost.leftvw ? s : rightmost
          ).id;
        }
      }

      // [5] = next spel (normally on same line, or first spel of line below if center is last)
      const rightSpels = centerLineSpels.filter(s => s.leftvw > centerSpel.leftvw);
      if (rightSpels.length > 0) {
        // There are spels to the right on the same line
        neighborhood[5] = rightSpels.reduce((closest, s) =>
          s.leftvw < closest.leftvw ? s : closest
        ).id;
      } else {
        // Center spel is last on its line, so [5] is first spel of line below
        const belowLineSpels = getSpelsOnLine(centerSpel.topvw + lineHeight);
        if (belowLineSpels.length > 0) {
          neighborhood[5] = belowLineSpels.reduce((leftmost, s) =>
            s.leftvw < leftmost.leftvw ? s : leftmost
          ).id;
        }
      }

      // [1] = spel most immediately above center spel on line above
      const aboveLineSpels = getSpelsOnLine(centerSpel.topvw - lineHeight);
      if (aboveLineSpels.length > 0) {
        const overlappingAbove = aboveLineSpels.filter(s => spelsOverlap(centerSpel, s));
        if (overlappingAbove.length > 0) {
          // Find the one with center closest to center spel's center
          const centerSpelCenter = centerSpel.leftvw + pxToVw(centerElem.offsetWidth) / 2;
          neighborhood[1] = overlappingAbove.reduce((closest, s) => {
            const sElem = document.getElementById(s.id);
            const sCenter = s.leftvw + pxToVw(sElem.offsetWidth) / 2;
            const closestElem = document.getElementById(closest.id);
            const closestCenter = closest.leftvw + pxToVw(closestElem.offsetWidth) / 2;
            return Math.abs(sCenter - centerSpelCenter) < Math.abs(closestCenter - centerSpelCenter) ? s : closest;
          }).id;
        }
      }

      // [7] = spel most immediately below center spel on line below
      const { firstLine, lastLine } = getFirstLastLinePositions();
      let belowLineSpels = getSpelsOnLine(centerSpel.topvw + lineHeight);

      // If no spels found on immediate line below
      if (belowLineSpels.length === 0) {
        if (Math.abs(centerSpel.topvw - lastLine) <= 0.5) {
          // Center spel is on the last line, wrap to first line
          belowLineSpels = getSpelsOnLine(firstLine);
        } else {
          // Center spel is not on last line, find next non-blank line
          const nextLineTopvw = findNextNonBlankLine(centerSpel.topvw);
          if (nextLineTopvw !== null) {
            belowLineSpels = getSpelsOnLine(nextLineTopvw);
          }
        }
      }

      if (belowLineSpels.length > 0) {
        const overlappingBelow = belowLineSpels.filter(s => spelsOverlap(centerSpel, s));
        if (overlappingBelow.length > 0) {
          // Find the one with center closest to center spel's center
          const centerSpelCenter = centerSpel.leftvw + pxToVw(centerElem.offsetWidth) / 2;
          neighborhood[7] = overlappingBelow.reduce((closest, s) => {
            const sElem = document.getElementById(s.id);
            const sCenter = s.leftvw + pxToVw(sElem.offsetWidth) / 2;
            const closestElem = document.getElementById(closest.id);
            const closestCenter = closest.leftvw + pxToVw(closestElem.offsetWidth) / 2;
            return Math.abs(sCenter - centerSpelCenter) < Math.abs(closestCenter - centerSpelCenter) ? s : closest;
          }).id;
        }
      }

      // [0] = spel to the left of [1] if it overlaps with center spel
      if (neighborhood[1]) {
        const spel1 = spels.get(neighborhood[1]);
        const spel1LineSpels = getSpelsOnLine(spel1.topvw).filter(s => s.id !== spel1.id);
        const leftOfSpel1 = spel1LineSpels.filter(s => s.leftvw < spel1.leftvw);
        if (leftOfSpel1.length > 0) {
          const immediateLeft = leftOfSpel1.reduce((closest, s) =>
            s.leftvw > closest.leftvw ? s : closest
          );
          if (spelsOverlap(centerSpel, immediateLeft)) {
            neighborhood[0] = immediateLeft.id;
          }
        }
      }

      // [2] = spel to the right of [1] if it overlaps with center spel
      if (neighborhood[1]) {
        const spel1 = spels.get(neighborhood[1]);
        const spel1LineSpels = getSpelsOnLine(spel1.topvw).filter(s => s.id !== spel1.id);
        const rightOfSpel1 = spel1LineSpels.filter(s => s.leftvw > spel1.leftvw);
        if (rightOfSpel1.length > 0) {
          const immediateRight = rightOfSpel1.reduce((closest, s) =>
            s.leftvw < closest.leftvw ? s : closest
          );
          if (spelsOverlap(centerSpel, immediateRight)) {
            neighborhood[2] = immediateRight.id;
          }
        }
      }

      // [6] = spel to the left of [7] if it overlaps with center spel
      if (neighborhood[7]) {
        const spel7 = spels.get(neighborhood[7]);
        const spel7LineSpels = getSpelsOnLine(spel7.topvw).filter(s => s.id !== spel7.id);
        const leftOfSpel7 = spel7LineSpels.filter(s => s.leftvw < spel7.leftvw);
        if (leftOfSpel7.length > 0) {
          const immediateLeft = leftOfSpel7.reduce((closest, s) =>
            s.leftvw > closest.leftvw ? s : closest
          );
          if (spelsOverlap(centerSpel, immediateLeft)) {
            neighborhood[6] = immediateLeft.id;
          }
        }
      }

      // [8] = spel to the right of [7] if it overlaps with center spel
      if (neighborhood[7]) {
        const spel7 = spels.get(neighborhood[7]);
        const spel7LineSpels = getSpelsOnLine(spel7.topvw).filter(s => s.id !== spel7.id);
        const rightOfSpel7 = spel7LineSpels.filter(s => s.leftvw > spel7.leftvw);
        if (rightOfSpel7.length > 0) {
          const immediateRight = rightOfSpel7.reduce((closest, s) =>
            s.leftvw < closest.leftvw ? s : closest
          );
          if (spelsOverlap(centerSpel, immediateRight)) {
            neighborhood[8] = immediateRight.id;
          }
        }
      }

      return neighborhood;
    }
  </script>
  <script id="18" type="application/vnd.observable.javascript" pinned="">
    mapParaSpels = (spannedCells, paraNames) => {
      let spels = new Map();
      for (const [idx, spannedCell] of spannedCells.entries()) {
        parasConfig[paraNames[idx]] = [];
        let spelArray = getSpelArray(spannedCell, spels.size);
        spelArray.forEach((spel) => {
          spels.set(spel.id, {
            id: spel.id,
            string: spel.string,
            leftvw: spel.leftvw,
            topvw: spel.topvw,
            html: spel.html
          });
          // array of spells added to paraName property of parasConfig
          parasConfig[paraNames[idx]].push(spel);
        });
      }
      return spels;
    }
  </script>
  <script id="19" type="application/vnd.observable.javascript" pinned="">
    getSpelArray = (spannedElem, size = 0) => {
      // builds the spels array of spel objects and returns styled spans for display
      let spelArray = [];
      let verseSpans = Array.from(spannedElem.children);
      verseSpans.forEach((span, idx) => {
        let spel = {};
        spel.id = span.innerText + "_" + (idx + size);
        spel.string = span.innerText;
        spel.leftvw = pxToVw(span.offsetLeft);
        spel.topvw = pxToVw(span.offsetTop);
        spel.html = `<span id="${spel.id}" class="spel" style="left:${spel.leftvw}vw;top:${spel.topvw}vw">${span.innerHTML}</span>`;
        spelArray.push(spel);
      });
      return spelArray;
    }
  </script>
  <script id="20" type="application/vnd.observable.javascript" pinned="">
    addSpansTo = (draftElem) => {
      let newText = ``; // this will hold html for the new draftSpanned cell
      let text = draftElem.innerHTML; // get existing innerHTML from from the pre element of verse cell
      let spelStart = text.search(/\S/); // find the first spel by finding first nonwhitespace
      while (spelStart != -1) {
        newText += text.substr(0, spelStart); // grab everything up to that point including whitespace
        text = text.substr(spelStart); // put the rest in text
        let spelEnd = text.search(/\s/); // find where whitespace starts again
        if (spelEnd == -1) spelEnd = text.length; // text ends with nonwhitespace
        // wrap the spel we've found in span tags
        newText += `<span>` + text.substr(0, spelEnd) + `</span>`; // add this to newText
        text = text.substr(spelEnd); // put the rest in text
        spelStart = text.search(/\S/); // find the next nonwhitespace (if any)
      }
      return newText;
    }
  </script>
  <script id="21" type="text/markdown">
    #### *Default linear* `scores` *produced by* `timeToRead()`
  </script>
  <script id="22" type="application/vnd.observable.javascript" pinned="">
    scoresDefaultTTR = {
      let scores = [];
      let spelIdx = 0;
      let paraCells = config.get("paraCells");
      for (let pIdx = 0; pIdx < paraCells.length; pIdx++) {
        let score = [];
        let paraElem = paraCells[pIdx];
        let paraSpels = parasConfig[config.get("paraNames")[pIdx]];
        let pauses = [],
          pausesIdx = 0;
        let textToProcess = paraElem.innerText,
          s = textToProcess.search(/\S/);
        while (s != -1) {
          let spaces = textToProcess.substr(0, s);
          textToProcess = textToProcess.substr(s);
          let l = textToProcess.search(/\s/);
          if (l == -1) l = textToProcess.length;
          let word = textToProcess.substr(0, l);
          pauses.push(timeToRead(word, pausesIdx++, spaces, pauses));
          textToProcess = textToProcess.substr(l);
          s = textToProcess.search(/\S/);
        }
        // Add bounds checking here
        pauses.forEach((p, idx) => {
          if (idx < paraSpels.length && paraSpels[idx]) {
            score.push({ id: paraSpels[idx].id, pause: p });
          } else {
            console.warn(`Missing spel at index ${idx} in paragraph ${pIdx}. Found ${pauses.length} pauses but only ${paraSpels.length} spels.`);
          }
        });
        scores.push(score);
      }
      return scores;
    }
  </script>
  <script id="23" type="application/vnd.observable.javascript" pinned="">
    timeToRead = (word, idx, spaces, pauses, factor = 1) => {
      let hundreths = 30;
      let vowelsOrPunc = word.match(/[aeiouy,:;\.\?]/gi);
      if (vowelsOrPunc) hundreths += (vowelsOrPunc.length * 15) / factor;
      if (idx - 1 > -1) {
        pauses[idx - 1] += (spaces.length * 7.5) / factor;
        let crs = spaces.match(/[\n\r]/gi);
        if (crs) pauses[idx - 1] += (crs.length * 100) / factor;
      }
      return hundreths;
    }
  </script>
  <script id="24" type="application/vnd.observable.javascript" pinned="">
    scoresFromAlignment = (alignmentJSON) => {
      let startingPara = 0; // Could be EDITed
      let numParas = paras.length;
      // let alignmentJSON = await FileAttachment("reading@1.m4a.json").json();
      let scores = [];
      let firstSpelId = paras[startingPara][0];
      // console.log(firstSpelId);
      // console.log(firstSpelId, firstSpelId.match(/\d+/)[0]); // DEBUG
      let spelNdx = parseInt(firstSpelId.match(/\d+/)[0]);
      for (let i = 0; i < numParas; i++) {
        let a = alignedSpels(
          alignmentJSON[startingPara + i],
          startingPara + i,
          spelNdx
        );
        spelNdx += a.length;
        // >>>  would add autofade here:
        // a.unshift({
        //   id: "AUTOFADE",
        //   pause: config.fadeWords
        // });
        // <<<
        scores.push(a);
      }
      return scores;
    }
  </script>
  <script id="25" type="application/vnd.observable.javascript" pinned="">
    function alignedSpels(alignmentJSON, _paraNum = 0, spelNdx = 0) {
      // build aligned spels
      // console.log("entered alignedSpels()"); // DEBUG
      let aSpels = [];
      alignmentJSON.forEach((alignedWord, idx) => {
        // get length of time taken to pronounce word:
        let p = alignedWord.end - alignedWord.start;
        // if we are not at the last word of the segment
        if (idx < alignmentJSON.length - 1) {
          // add the difference between start of next word and end of this one
          p = p + (alignmentJSON[idx + 1].start - alignedWord.end);
        }
        p = Math.round(p * 100); // convert to hundreths
        // in this project all spell id's are unique because serial numbers are added
        let spelId = alignedWord.word.trim() + "_" + spelNdx++;
        if (!spels.has(spelId))
          console.log(`alignment problem at: ${spelId} in para: ${_paraNum}`);
        aSpels.push({
          id: spelId,
          pause: p
        }); // spels[idx]
      });
      return aSpels;
    }
  </script>
  <script id="26" type="module" pinned="">
    const lastSpel = Array.from(spels.values()).pop();
    display(`${lastSpel.string}: ${Math.ceil(lastSpel.topvw + 3)}`);
  </script>
  <script id="27" type="text/html" pinned="">
    <h4>CSS</h4>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap');

      .set {
        white-space: pre-wrap;
        width: 60vw;
        position: relative;
        font-family: "Roboto Mono", "Andale Mono", sans-serif;
        font-size: 2vw;
        font-variant-ligatures: no-common-ligatures;
        font-optical-sizing: auto;
        font-style: normal;
        font-weight: 300;
        /* font-variation-settings:
          "wght" 300,
          "wdth" 100,
          "YTLC" 500; */
        line-height: 1.5;
        color: black;
      }

      .spel {
        position: absolute;
        opacity: 1;
        background-color: navajowhite;
        transition: all .5s ease-in-out;
        -o-transition: all .5s ease-in-out;
        -ms-transition: all .5s ease-in-out;
        -moz-transition: all .5s ease-in-out;
        -webkit-transition: all .5s ease-in-out;
      }

      .spel.visible {
        opacity: 1;
      }

      #display {
        position: relative;
        background-color: antiquewhite;
        color: darkslategray;
        /* cursor: none; */
        height: 352vw;
        overflow: hidden;
      }
    </style>
  </script>
  <script id="28" type="text/markdown">
    #### General utilities
  </script>
  <script id="29" type="application/vnd.observable.javascript" pinned="">
    // converts pixel measurements to the more flexible vw (viewport width) measurement of css
    pxToVw = (px) => px * (100 / vWidth) // document.documentElement.clientWidth
  </script>
  <script id="30" type="application/vnd.observable.javascript" pinned="">
    vWidth = Math.max(
      document.documentElement.clientWidth || 0,
      window.innerWidth || 0
    )
  </script>
  <script id="31" type="application/vnd.observable.javascript">
    // shuffles an array
    shuffle = (src) => {
      let a = [...src];
      let i = a.length;
      while (--i > 0) {
        let j = ~~(Math.random() * (i + 1)); // ~~ is a common optimization for Math.floor
        let t = a[j];
        a[j] = a[i];
        a[i] = t;
      }
      return a;
    }
  </script>
  <script id="32" type="application/vnd.observable.javascript" pinned="">
    randInt = (maxPlusOne) => (maxPlusOne * Math.random()) | 0
  </script>
  <script id="33" type="application/vnd.observable.javascript">
    import { StrictObj } from "@shadoof/utils"
  </script>
  <script id="34" type="text/markdown">
    ---
    ### Spanned Drafts
  </script>
  <script id="35" type="module" pinned="">
    const spanned = htl.html`<div class="set"></div>`;
    spanned.innerHTML = addSpansTo(draft);
    display(spanned);
  </script>
  <script id="37" type="text/x-typescript" pinned="">
    spanned.innerHTML
  </script>
  <script id="36" type="module" pinned="">
    // Import specific RiTa functions
    import { RiTa } from "npm:rita";
    const { phones } = RiTa;
    // Example usage
    display("Phonemes for 'hello':");
    display(phones("hello"));
  </script>
</notebook>
