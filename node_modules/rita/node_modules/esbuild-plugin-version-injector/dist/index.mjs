import { Result } from '@sapphire/result';
import { readFile } from 'node:fs/promises';
import { resolve, extname } from 'node:path';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/regexpEscape.ts
var REGEXPESC = /[-/\\^$*+?.()|[\]{}]/g;
function regExpEsc(str) {
  return str.replace(REGEXPESC, "\\$&");
}
__name(regExpEsc, "regExpEsc");

// src/StringReplaceAllPolyfill.ts
if (!String.prototype.replaceAll) {
  String.prototype.replaceAll = /* @__PURE__ */ __name(function replaceAll(str, newStr) {
    if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
      return this.replace(str, newStr);
    }
    return this.replace(new RegExp(regExpEsc(str), "g"), newStr);
  }, "replaceAll");
}

// src/index.ts
var VersionOrCurrentDate = /* @__PURE__ */ ((VersionOrCurrentDate2) => {
  VersionOrCurrentDate2["Version"] = "version";
  VersionOrCurrentDate2["CurrentDate"] = "current-date";
  return VersionOrCurrentDate2;
})(VersionOrCurrentDate || {});
function getFilter(options) {
  if (!options.filter) {
    return /.*/;
  }
  if (Object.prototype.toString.call(options.filter) !== "[object RegExp]") {
    console.warn(
      `Plugin "esbuild-plugin-version-injector": Options.filter must be a RegExp object, but gets an '${typeof options.filter}' type. 
This request will match ANY file!`
    );
    return /.*/;
  }
  return options.filter ?? /.*/;
}
__name(getFilter, "getFilter");
function getInjectTag(options) {
  return options.injectTag ?? "[VI]{{inject}}[/VI]";
}
__name(getInjectTag, "getInjectTag");
async function getVersionOrCurrentDate(options) {
  const { versionOrCurrentDate } = options;
  if (versionOrCurrentDate === "current-date" /* CurrentDate */) {
    return (/* @__PURE__ */ new Date()).toISOString();
  }
  const packageFile = await Result.fromAsync(readFile(resolve(options.packageJsonPath ?? "./package.json"), { encoding: "utf-8" }));
  if (packageFile.isErr()) {
    return null;
  }
  const packageJson = Result.from(JSON.parse(packageFile.unwrap()));
  if (packageJson.isErr()) {
    return null;
  }
  const packageJsonVersion = packageJson.unwrap().version;
  if (!packageJsonVersion) {
    return null;
  }
  return packageJsonVersion;
}
__name(getVersionOrCurrentDate, "getVersionOrCurrentDate");
function getEsbuildLoader(args) {
  const resolvedExtName = extname(args.path);
  switch (resolvedExtName) {
    case ".ts":
    case ".mts":
    case ".cts":
      return "ts";
    case ".jsx":
    case ".tsx":
      return "tsx";
    case ".json":
      return "json";
    case ".css":
    case ".scss":
    case ".sass":
    case ".less":
    case ".styl":
      return "css";
    case ".txt":
      return "text";
    case ".js":
    case ".cjs":
    case ".mjs":
    default:
      return "js";
  }
}
__name(getEsbuildLoader, "getEsbuildLoader");
async function handleOnLoad(args, options) {
  const injectTag = getInjectTag(options);
  const fileResult = await Result.fromAsync(readFile(args.path, { encoding: "utf-8" }));
  if (fileResult.isOk()) {
    let unwrappedFileContents = fileResult.unwrap();
    const hasInjectTag = unwrappedFileContents.includes(injectTag);
    if (hasInjectTag) {
      const versionOrCurrentDate = await getVersionOrCurrentDate(options);
      if (versionOrCurrentDate) {
        unwrappedFileContents = unwrappedFileContents.replaceAll(injectTag, versionOrCurrentDate);
      }
    }
    return {
      pluginData: args.pluginData,
      contents: unwrappedFileContents,
      loader: getEsbuildLoader(args)
    };
  }
  return void 0;
}
__name(handleOnLoad, "handleOnLoad");
async function handleOnEnd(results, filter, options) {
  const injectTag = getInjectTag(options);
  for (const file of results.outputFiles ?? []) {
    if (!filter.test(file.path)) {
      continue;
    }
    const hasInjectTag = file.text.includes(injectTag);
    if (hasInjectTag) {
      const versionOrCurrentDate = await getVersionOrCurrentDate(options);
      if (versionOrCurrentDate) {
        const decoded = new TextDecoder().decode(file.contents);
        const replaced = decoded.replaceAll(injectTag, versionOrCurrentDate);
        file.contents = new TextEncoder().encode(replaced);
      }
    }
  }
}
__name(handleOnEnd, "handleOnEnd");
function esbuildPluginVersionInjector(options = {
  filter: /.*/,
  versionOrCurrentDate: "version" /* Version */,
  injectTag: "[VI]{{inject}}[/VI]",
  packageJsonPath: "./package.json"
}) {
  const filter = getFilter(options);
  const { namespace } = options;
  return {
    name: "esbuild-plugin-version-injector",
    setup(build) {
      if (!options.disableOnLoadTrigger) {
        build.onLoad({ filter, namespace }, (args) => handleOnLoad(args, options));
      }
      build.onEnd((results) => handleOnEnd(results, filter, options));
    }
  };
}
__name(esbuildPluginVersionInjector, "esbuildPluginVersionInjector");
var version = "1.2.1";
/**
 * https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/regExpEsc.ts
 * @author The Sapphire Community and its contributors
 * @license MIT
 */
/**
 * Cleans a string from regex injection
 * @param str The string to clean
 * https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/regExpEsc.ts
 * @author The Sapphire Community and its contributors
 * @license MIT
 */
/**
 * String.prototype.replaceAll() polyfill
 * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
 * @author Chris Ferdinandi
 * @license MIT
 */

export { VersionOrCurrentDate, esbuildPluginVersionInjector, version };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map